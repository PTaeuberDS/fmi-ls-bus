= Network Communication and FMI 3.0, v1.0
:doctype: book
:imagesdir: images
:sectnums:
:sectnumlevels: 5
:toc: left
:toc-title: Contents
:toclevels: 5
:xrefstyle: short
:docinfo: shared
:stylesheet: fmi-spec.css
:stem: latexmath
:source-highlighter: highlightjs
:nofooter:
:favicon: images/favicon.ico
:icons: font

// TODO dSPACE: Step 1: Rethink document structure:
// e.g. something like:
// Common Concepts
// Network Communication with High Cut
// Network Communication with Low Cut
//    General Event/OP Code mechanism
//    CAN (with OP Codes)
//    LIN (with OP Codes)
//    Ethernet (with OP Codes)
//    ...

// TODO dSPACE: Step 2:
// - Write section General Event/OP Code mechanism
// - Write section (CAN with OP Codes)

// TODO dSPACE: Step x:
// - Write section (Ethernet with OP Codes)
// - Write section (LIN with OP Codes)

This layered standard on top of FMI 3.0, defines how to describe and simulate network signals as input and output variables of an FMU.

{empty} +
{empty}

Copyright (C) 2022 The Modelica Association Project FMI.

This document is licensed under the Attribution-ShareAlike 4.0 International license.
The code is released under the 2-Clause BSD License.
The licenses text can be found in the https://raw.githubusercontent.com/modelica/fmi-standard/master/LICENSE.txt[LICENSE.txt] file that accompanies this distribution.

{empty}

== Introduction

=== Intend of this Document

Automotive CAN, LIN, FlexRay, CAN FD and CAN XL are network technologies that have been applied successfully over many years by all automotive OEMs world wide.
Virtualizing electronic control units (ECUs) and then simulating multiple such virtual ECUs requires connecting them using a virtual version of these network technologies.

This layered standard defines what input and output variables and which FMI 3.0 features are used and how to emulate a transport layer for such network traffic.

There are mainly two base use cases envisioned here:

 - Physical signal abstraction ("high cut") to simply transport physical signal values between virtual ECUs. +
   The network properties are largely idealized: infinite bandwidth, zero-delay etc.
   Signals, groups of signals and their properties (e.g. units) are usually derived from (existing and validated) standard network topology description formats (such as DBC, LDF, Fibex and ARXML).
 - Frame abstraction ("low cut") to facilitate MCAL emulations. +
   This transport layer emulation allows anything from idealized to more detailed network simulations, including bandwidth restrictions, message arbitration and delays and it forwards the network payloads using binary variables.
   The "low cut" abstraction layer is meant to allow virtualized MCAL driver implementations, including feedback from the physical drivers about send timing, rejection or network errors.

In the simplest use case, the importer does not need to know about the special network semantics of certain variables of an FMU; it simply forwards variable values between 2 FMUs according to the FMI standard (<<multiOutput,with one exception noted at the end of the document>>).
Only when more than two FMUs are connected to a single network a bus simulation component is required to merge and then forward the network interface semantics of the different variables from multiple output variables to multiple input variables.

See the following image describing three potential architectures for connecting two or more networked virtual ECUs packaged into FMI 3.0 FMUs:

.3 ways to connect virtual ECU network variables.
[#vECU-network-architectures]
image::architecture.svg[width=80%, align="center"]


=== Basic Mechanisms of this Layered Standard

Both abstraction layers are similar in many respects and can be translated into one another using the <<NetworkDescriptionFile,network description files>>.
Depending on the export tool, one of the abstraction layers is more "natural" to the FMU, while the other might have to be emulated with additional internal effort or an adapter (FMU) could be used.
Importers on the other hand rarely require both abstraction layers for system level compositions, because the engineering tasks define the required level of abstraction for the network communication.
FMUs may choose to only support one abstraction layer providing only the corresponding variables.
However, for versatility, having FMUs capable of communicating on both abstraction layers is more convenient for users.

_[FMUs providing both abstraction layers can deduce from the fmi3Set() and fmi3Get() calls they receive, which abstraction layer the importer is using.]_

Since network communication is not continuous but time discrete, FMI 3.0 clocks are used to indicate when signals and/or frames are sent or received.
All signal and frame variables are clocked variables.

FMI 3.0 terminal definitions in the `terminalsAndIcons.xml` for each level of grouping (networks, frames and PDUs) allow system composition tools without knowledge of the network description format to semantically group signals.
To uniquely map between the FMU variables and the network variables, FMU variable names are structured, e.g. `BusName::FrameName::PDUName::SignalName`.

// TODO AJ: explanation of clock and binary (check names!) variables for low cut; clock type influences and flexibilities; not use of nextEventTime

All variables have structured names that indicate how these variables are related and to which abstraction layer they belong.
For the high cut, variables represent signals and their clocks.
For the low cut, variables represent frames and their clocks.
Input and output variables show if these variables belong to signals or frames that are received or sent, respectively.
Input clocks must be triggered and are connected by the importer to their corresponding output clocks of potentially different clock types.
For example, a periodic output clock indicates that the FMU can only send signals or frames periodically, while a countdown clock indicates that the FMU can send signals at varying time steps.

Using output clocks of different types allows simulations with different timing accuracy and performance.
These clocks allow the FMU to specify the next send event efficiently and accurately, the importer will trigger these clocks according to these clock specifications as accurately as it can.

_[The alternative of using `nextEventTime` would force epsilon matching of event times.]_

// TODO AJ: Fix and variable step size influence on buffering of transport-layer events and their binary variables
//  -> high cut is different: no buffering possible: each send must be handled as Event
For any periodic (fixed-time) sending of messages, multiple message sends fall into one `doStep`.
While high-cut signal variables will miss all but the last value sent, low-cut frame variables will buffer all payloads inside their value.

If an FMU represents network nodes that are both sender and receiver of a signal, the receiver role will be removed from the FMU interface to allow the signals to have a unique role as output and the reading of such outputs must be handled internally to the FMU.

_[The FMI standard requires a variable to be either input or output.]_

// TODO: is this correct? does that also work for network simulations? how else to solve this unique-variable-name requirement?

// TODO AJ: structure of binary variable: event code plus parameters, potentially multiple parameter sets as send and confirm events must be buffered

While the values and semantic of the clock variables are clear, the binary frame variables are opaque to the importer but have internal structure to implement the transport layer of the specific network technology, see <<FrameVariable>>.
Frame variables do not just transport the network-specific payload, but also carry protocol-specific status information.
Status information allows, for example, the MCAL emulation of a virtual ECU to report back to the COM-stack about success or errors of a send request.


== Details

=== Network Description Files [[NetworkDescriptionFile,network description file]]

// TODO AJ: remove old requirements for network description files (not needed anymore): make it optional

Standardized <<NetworkDescriptionFile,network description files>> can be shipped with each FMU to describe properties of signals and frames, such as signal units, frame composition and trigger conditions.
These <<NetworkDescriptionFile,network description files>> must be placed into the `/extra/org.fmi-standard.fmi-ls-bus` folder.
DBC, LDF, Fibex and ARXML files are allowed, e.g. `Powertrain.dbc`.
The case sensitive root name of the <<NetworkDescriptionFile>> must be used as network identifier in the bus terminal type and prefix in the variable names.

Multiple files can be specified, each one defining one network used by the FMU.
This standard does not support composing one network from multiple <<NetworkDescriptionFile,network description files>>, even if using internal include mechanisms, it rather enforces the rule: one network - one file.

It is recommended to use ARXML over DBC files for CAN whenever possible, because the DBC standard lacks some key frame/PDU properties that were added only later using non-standard extensions with different dialects in use.

This document does not address potential open points of these description formats, it is assumed that such ambiguities will be handled elsewhere (e.g. message timing in the DBC format).
This document does not address IP protection or copyright issues.
These are technical and legal issues that need attention from standardization bodies of the referenced description formats, tool vendors and end users.


=== Variables

This section explains the different variable types used to carry network traffic through FMI input and output variables.

==== Signal Variables

To define the signal abstraction layer (or "high cut"), signal variables are defined.

A signal variable carries the physical value of a network signal normally packaged inside a PDU or frame.
The unit definition of the variable must match the one defined in the <<NetworkDescriptionFile>>.

Each network signal must be listed as <<TerminalMemberVariable>> of its corresponding <<PDUTerminal>>.

In case multiplexed signals are present in a frame/PDU: all signals are present, but only the active signal according to the multiplex switch signal contains a valid value, all inactive variables have undefined values _[those values could even be outside their specified min-max range without fault]_.

Generally, signal variables are optional, but they must either be all missing or all present to clearly indicate support for the signal abstraction layer.

All signal variables are clocked to indicate when exactly they have been sent, see <<ClockVariable>>.

==== Frame Variables [[FrameVariable, Frame Variables]]

// TODO AJ: this needs to change completely: This is now "Data"

To define the frame abstraction layer (or "low cut"), frame variables are used.

A frame variable is of type `fmi3Binary` and contains one or more binary frames, as sent by the network.
There are two such frame variables per bus: an input and an output.
The names of these frame variables are defined as `BusName::Rx_Data` and `BusName::Tx_Data`, e.g. `Powertrain::Rx_Data` and `Powertrain::Tx_Data` (see <<Example>>).

// TODO all: names for the frame could use improvement!

Both input and output frame variables must be listed as <<TerminalMemberVariable>> of its corresponding <<BUSTerminal>>.

// TODO all: are frame variables optional or mandatory? If both cut levels are optional (currently "high cut" is), we need to define that at least one of them must be present

Generally, frame variables are optional, but they must either both be missing or present to clearly indicate support for the frame abstraction layer ("low cut").

The senders of network frames can chose how many frames are buffered and/or for how long frames are buffered before activating an output clock to trigger the actual sending of these frames.
This allows senders to trade accuracy for speed: buffering more and interrupting the simulation less will lead to faster simulations, but less accurate timing of the network communication, see <<ClockVariable>>.

// TODO all: MIME types: org.fmi-standard.fmi-ls-bus.v1.[CAN|CANFD|LIN|FlexRay|Ethernet|SPI] -- anything missing? names good?

The following table lists the names of MIME types used for frame variables:

[#table-mime-types]
[cols="4,5",options="header"]
|====
|MIME type name
|Description

|org.fmi-standard.fmi-ls-bus.v1.CAN
|binary variables simulating the automotive CAN network

|org.fmi-standard.fmi-ls-bus.v1.CANFD
|binary variables simulating the automotive CANFD network

|org.fmi-standard.fmi-ls-bus.v1.LIN
|binary variables simulating the automotive LIN network

|org.fmi-standard.fmi-ls-bus.v1.FlexRay
|binary variables simulating the automotive FlexRay network

|org.fmi-standard.fmi-ls-bus.v1.Ethernet
|binary variables simulating the automotive Ethernet network

|org.fmi-standard.fmi-ls-bus.v1.SPI
|binary variables simulating the automotive SPI network

|====

The content of a binary variable is any number of frames, including none.
There are different frame types, listed in the following table:

[#table-frame-contenct]
[cols="4,3,3, 3,3,3, 2,2,2, 2,2,2"]
|====
.2+h|Frame type
5+h|Frame content
6+h|Network type support

h|OP Code
3+h|Specific content
h|Repeated
h|CAN
h|CANFD
h|LIN
h|FlexRay
h|Ethernet
h|SPI

|NOOP
|0x0000
3+|---
|Single
|yes
|yes
|yes
|yes
|yes
|yes

|Transmit
|0x01ff
|4 byte Frame ID
|1 byte Data Length
|n byte Data
|Multiple
|yes
|yes
|yes
|yes
|yes
|yes

|Confirm
|0x0284
3+|4 byte Frame ID
|Multiple
|yes
|yes
|yes
|yes
|yes/no
|no

|Network Error
|0x0304
3+|4 byte error code
|Single
|yes
|yes
|yes
|yes
|yes
|no

|Frame Error
|0x0408
|4 byte Frame ID
2+|4 byte error code
|Single
|yes
|yes
|yes
|yes
|yes
|no

|Config Baud
|0x0504
3+|4 byte rate
|Single
|yes
|yes
|yes
|no
|no
|yes

|Config Clocks
|0x0604
3+|4 byte clock config
|Single
|no
|no
|no
|yes
|no
|yes

|Wakeup
|0x0700
3+|---
|Single
|no
|no
|no
|yes
|no
|yes

|Status
|0x0804
3+|??? 4 bytes ???
|Single
|?
|?
|?
|?
|yes
|?

|====

The OP code contains an operation byte and encodes the size of the OP specific content field length (except Transmit frames with 0xef if frame has variable length with its own length field) and a repeat-bit (most significant bit of the second byte).
The following table shows the OP Code structure:

// TOTDO all: the follow could be compressed into a single byte, but would that help?

[#table-opcode-structure]
[cols="4,3,3"]
|====
h|Type
h|Repeat content
h|Length

|8 bit
|1 bit
|7 bit

|====

// TODO all: we need a table here with network and message errors here

==== Clock Variables [[ClockVariable]]

// TODO AJ: Add description of Event Mode handling here and how the countdown clock pre-schedules events into the future for performance reasons


In order to use FMU input and output variables as transport layer for networks, input and output clocks are used.
Such a clock is scheduled by the sending FMU to indicate the transmission of the corresponding frame or frames.

The output clock type, periodic or aperiodic, is defined by the sending FMU.
This allows the FMU (or better the exporting tool) to balance the accuracy and performance of its network communication:

 - While aperiodic clocks allow very accurate network simulations, frequently entering Event Mode will reduce the network simulation speed.
 - Using periodic clocks and buffering the frames to be transmitted reduces the number of Event Modes required and speeds up the simulation at the cost of simulation accuracy.
 - One could use (structural) parameters to define the accuracy of aperiodic clocks, allowing control of the simulation accuracy and performance with the same FMU.
 - The input clocks shall be triggered clocks.

The importer will then connect and merge output clock activations, even those of different clock types, and forwards them to the input clocks, as required by the network semantics.

All signal variables are clocked variables.
Signal variables belonging to frame `BusName::FrameName` are triggered by the clock `BusName::FrameName_Clock` and all these variables and their corresponding clock must share the same `causality` (`input` or `output`).

Both frame variables are clocked variables.
The input frame variable `BusName::Rx_Data` is clocked by the clock variable `BusName::Rx_Clock`, both with `causality` set to `input`.
The output frame variable `BusName::Tx_Data` is clocked by the clock variable `BusName::Tx_Clock`, both with `causality` set to `output`.
Both clock variables must also be listed as <<TerminalMemberVariable>> of its corresponding <<BUSTerminal>>.

.Example for network simulation.
[#figure-example-network-simulation]
image::bus_simulation_example.svg[width=80%, align="center"]

// TODO AJ: Add description of Event Type and their respective parameters and applicability to the different protocol types (mimic table)

// TODO all: Should we mandate that all output clock types must be the same? Or should we allow the exporter to mix clock types for the different abstraction layers, or even for the different frames? Since different FMUs might use different clock types anyway, an importer needs to handle the mixed case anyway. Any other reason to be more strict here?

==== Network Parameters [[NetworkParameters]]

// TODO all: define parameter names and their semantics influencing bus behavior and/or version of the fmi-ls-bus version (FMU declares them as parameters or structural parameters depending on internal mechanisms)

=== Network Simulation [[NetworkSimulation]]

.Example network simulation architecture.
[#figure-example-network-simulation-architecture]
image::architecture_bus_simulation_importer.svg[width=80%, align="center"]

The figure above shows one example for a network simulation architecture.
The importer is able to handle FMU input and output variables with network semantics:
The importer merges output clock activations, output binary data and output signal variables and forwards the results to their corresponding input variables.

The accuracy/performance of the resulting network simulation can range from ideal (no bandwidth restriction, no arbitration, no network errors) to more realistic (with restricted bandwidth, message delay due to arbitration, network errors, error injection, ...).

=== Terminal Definitions

==== Bus Terminal [[BUSTerminal,bus terminal]]

Each network connected to the FMU must be described in `icons/terminalsAndIcons.xml` as a `<Terminal>` element of `<fmiTerminalsAndIcons><Terminals>` that wraps all <<FrameTerminal,frame terminals>>.
The attribute `name` of the `<Terminal>` must match the root name of its <<NetworkDescriptionFile>> if it exists
_[e.g. `Powertrain`, if the file is `/extra/org.fmi-standard.fmi-ls-bus/Powertrain.dbc`]_.
In any case, the attribute `name` of the `<Terminal>` must be consistent with the `BusName` component of all its corresponding signal, frame and clock variables.

Attribute definitions::
 * `terminalKind` must be set to `bus`.
 * `matchingRule` must be set to `bus`.
 * `name` is the network name, e.g. `Powertrain`, see <<Example>> and constraints above.

Element definitions::
 * If frame variables (`BusName::Rx_Data` and `BusName::Tx_Data`) and their clocks (`BusName::Rx_Clock` and `BusName::Tx_Clock`) are exposed in the `modelDescription.xml`, they must be listed as `<TerminalMemberVariable>` elements here.
 These variables represent the frame abstraction layer ("low cut").
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be one `<Terminal>` element per network frame described in the <<NetworkDescriptionFile>>, if their signal and lock variables are present in the `modelDescription.xml`.

Annotation element::
 * There must be an `<Annotation>` element defining which node or nodes (as comma-separated list without spaces) of the <<NetworkDescriptionFile>> are wrapped inside the FMU.
If the combination of nodes specified for this FMU turns a frame and its signals into both input and output because sending and receiving nodes are specified, only the sending (output) role will be defined in the FMU interface.
Receiving such frames must then be handled internally to the FMU.

.Frame variables and terminals.
[#figure-frame-variables-terminals]
image::bus_terminal.svg[width=80%, align="center"]

==== Frame Terminal [[FrameTerminal,frame terminal]]

Each frame listed in the <<NetworkDescriptionFile>> must be an element of its corresponding <<BUSTerminal>>.

Attribute definitions::
 * `terminalKind` must be set to `frame`.
 * `matchingRule` must be set to `bus`.
 * `name` must match the frame name as defined in the <<NetworkDescriptionFile>> in `/extra/org.fmi-standard.fmi-ls-bus`.

Element definitions::
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be one <<PDUTerminal>> element per PDU of this frame.
 * There must be one `<TerminalMemberVariable>` for the clock this frame is connected to.
   The name of this variable is composed as <<ClockVariable,`BusName::FrameName_Clock`>>, e.g. `Powertrain::tcuSensors_Clock`.

The <<TerminalMemberVariable>> must have the same causality as all variables referenced in the <<PDUTerminal,PDU Terminals>> included here.

==== PDU Terminal [[PDUTerminal,PDU terminal]]

Each PDU listed in the <<NetworkDescriptionFile>> must be an element of its corresponding <<FrameTerminal>>.

Attribute definitions::
 * `terminalKind` must be set to `pdu`.
 * `matchingRule` must be set to `bus`.
 * `name` must match a PDU name of the <<NetworkDescriptionFile>> in `/extra/org.fmi-standard.fmi-ls-bus`, if given.
    For network types not natively referencing a "PDU", like CAN, a synthetic PDU with the same name as its frame is inserted.

Element definitions::
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be no `<Terminal>` element.
 * There must be one `<TerminalMemberVariable>` per <<TerminalMemberVariable,signal>> of this PDU.

All <<TerminalMemberVariable,`TerminalMemberVariables`>> must have the same causality of either `input` or `output`.

==== Terminal Member Variable for Signals [[TerminalMemberVariable,Terminal Member Variable]]

<<PDUTerminal,PDU terminals>> list all the contained signals as `<TerminalMemberVariable>`.

Attribute definitions::
 * `variableName` refers to the input or output variable name of the FMU and to enforce uniqueness is built as follows: `BusName::FrameName::PDUName::SignalName`, e.g. `Powertrain::tcuSensors::tcuSensors::vCar`.
    These variables represent the signal abstraction layer ("high cut").
 * `memberName` is the `SignalName` as given in the <<NetworkDescriptionFile>>, e.g. `vCar`, if given.
    This is redundant information but simplifies signal name extraction.
 * `variableKind` is `signal`.

=== Example [[Example,Example]]

The following excerpts from files are used throughout this document as examples and should illustrate how the different concepts relate.

The following partial DBC file lists merely the CAN message (frame) structure.
Signal trigger conditions are not included because they have no bearing on this standard.

.Example Powertrain.dbc file
[#Powertrain.dbc]
[source, C]
----
...
BO_ 256 tcuSensors: 4 TCU
 SG_ vCar :          0|16@1- (32,0)  [-500|500] "km/h" ECU
 SG_ oilTemp :      16|9@1-  (2,50)  [-50|150]  "Grad C" ECU

BO_ 257 tcuState: 2 TCU
 SG_ state :         0|2@1+  (1,0)   [ 0|2] "-" ECU
 SG_ gear :          2|4@1-  (1,0)   [-2|6] "-" ECU
 SG_ targetGear :    6|4@1-  (1,0)   [-2|6] "-" ECU

BO_ 512 ecuState: 4 ECU
 SG_ accelPedal :    0|8@1+ (2,0)   [0|100]   "%" TCU
 SG_ k15 :           8|1@1+ (1,0)   [0|1]     "-" TCU
 SG_ oilTemp :       9|9@1- (2,50)  [-50|150] "Grad C" TCU
 SG_ radiatorTemp : 18|9@1- (2,50)  [-50|150] "Grad C" TCU
...
----

The `modelDescription.xml` excerpt listed below shows which variables would exist for the `Powertrain.dbc` shown above.

.Example modelDescription.xml for ECU node
[#modelDescription.xml]
[source, XML]
----
include::examples/X_network4FMI_modelDescription.xml[]
----

The following file shows the `<Terminal>` definition representing the network and frame structure defined with `Powertrain.dbc` above.

.Example terminalsAndIcons.xml file
[#terminalsAndIcon.xml]
[source, XML]
----
include::examples/X_network4FMI_terminalsAndIcons.xml[]
----

=== Known Limitations of this Standard

This layered standard maps several network protocols onto co-simulation variables as transport layer simulating in many ways an ideal network.
Such an ideal network differs from physical networks in the following ways (and potentially others):

 * Network frame arbitration: frames are sent on the wire according to network-specific priority rules. +
   Here all frames are transmitted at the same time without delay.

 * Network congestion/bandwidth: too many network frames sent for the bandwidth of the network. +
   Here the network has infinite capacity. +
   If network properties are required, a bus simulation component must be added or included with the importer.

 * Protocol functions of higher levels: i.e. CAN request for retransmit is a specific protocol function. +
   Here such specialties must be handled by the first layer inside the FMU.

 * Incoming buffer overflow: when an ECU receives more frames than its buffer can hold. +
   Here the FMU will receive all frames, regardless of buffer size and would need to handle those limitations internally.

 * [[multiOutput]]Network protocols allow frames to be sent from more than one node. +
   Here this is also possible, with output variables for frames (and their signals) that are sent by more than one FMU.
   This requires the importer to handle the case when multiple source FMUs are sending the same frame.
   Importers must know how to handle this, just like they must know how to handle flow variables according to Kirchhoff's law.
